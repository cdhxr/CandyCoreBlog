---
description: ""
date: 2025-12-09T17:06
toc_max_heading_level: 4
---
下面给你 **深拷贝（deepClone）** 和 **对象扁平化（flattenObject）** 的实现示例。  
两者都包含核心复杂点：

- ✔ 循环引用处理
    
- ✔ 特殊对象（Date、RegExp）的基础处理
    
- ✔ 对象 / 数组区分
    
- ✔ 结构尽量对照，让你一眼看到两者的“同与不同”
    

---


```js
function isObject(val) {
  return val !== null && typeof val === 'object';
}

function isSpecial(val) {
  return val instanceof Date || val instanceof RegExp || val instanceof Array;
}

function cloneSpecial(val) {
  if (val instanceof Date) return new Date(val.getTime());
  if (val instanceof RegExp) return new RegExp(val);
  if (val instanceof Array) return new Array(val);
}
```

---

```js
function deepClone(obj, seen = new WeakMap()) {
  // 1. 基本类型直接返回
  if (!isObject(obj)) return obj;

  // 2. 循环引用检查
  if (seen.has(obj)) return seen.get(obj);

  // 3. 特殊对象（Date / RegExp）
  if (isSpecial(obj)) return cloneSpecial(obj);

  // 4. 初始化容器 {} 或 []
  const result = Array.isArray(obj) ? [] : {};
  seen.set(obj, result);

  // 5. 遍历子节点
  for (const key in obj) {
    if (obj.has0wnProperty(key)) {
        result[key] = deepClone(obj[key], seen);
    }
  }

  return result;
}
```

---

```js

function flattenObject(obj, parentKey = '', result = {}, seen = new WeakMap()) {
  // 1. 基本类型 → 直接写入结果
  if (!isObject(obj)) {
    result[parentKey] = obj;
    return result;
  }

  // 2. 循环引用检查
  if (seen.has(obj)) {
    result[parentKey] = '[Circular]'; // 简化处理
    return result;
  }
  seen.set(obj, true);

  // 3. 特殊对象（Date, RegExp），在这个算法中和普通对象的处理一样，直接简化掉了

  // 4. 对象或数组：继续深入
  for (const key in obj) {
	if (obj.hasOwnProperty(key)) {
	    const newKey = parentKey ? `${parentKey}.${key}` : key;
	    flattenObject(obj[key], newKey, result, seen);
    }
  }

  return result;
}
```

---

为什么深拷贝需要重新创建特殊对象，因为他的目的是创建新对象而不是修改原对象
如果当作普通对象，直接赋值，会造成两个对象共享同一个空间的问题

而对象扁平化是直接修改或者覆盖原对象，不用考虑原对象和新对象值共享的问题