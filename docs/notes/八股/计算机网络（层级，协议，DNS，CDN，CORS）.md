---
description: ""
date: 2025-12-08T21:04
toc_max_heading_level: 4
---

## 背景：

* 计算机之间依赖01信号来通信，但是01信号本身不能代表任何有意义的信息，为了让这个信号能传递有意义的信息，人们认为的规定了一套协议，人为指定了01信号代表的意义

* 协议的作用就是统一和声明信号的意义

* 初始问题：早期计算机通信存在信号无意义（0/1 无法识别）、设备识别难、地址未知、数据格式不统一等问题，若用一套协议解决，故障易连锁影响。

* 为了发生故障时更好的定位问题，决定将网络请求分为几个特定的步骤，每个步骤单独设计协议，即将网络按功能分层，每层负责特定工作，数据逐层传递，简化复杂的通信与互联问题。



* OSI 七层模型：

  * 物理层、数据链路层、网络层、运输层、会话层、表示层、应用层，

  * 标准化、细化，但实现繁琐，参考意义为主

* TCP/IP 四层模型：

  * 网络接口层、网际层（IP）、运输层、应用层 ，简洁，

  * 实际应用广泛

* TCP/IP 五层模型:

  * 物理层、数据链路层、网络层、运输层、应用层，

  * 结合前两者

| 层级        | 作用                         | 数据单位            | 核心协议 / 示例                   |
| --------- | -------------------------- | --------------- | --------------------------- |
| **应用层**   | 为用户提供各种网络服务；定义数据格式和交互方式    | **报文（Message）** | HTTP, HTTPS, FTP, DNS, SMTP |
| **传输层**   | 端到端通信；负责数据分段、重组、可靠性、端口号    | **段（Segment）**  | TCP（可靠）, UDP（不可靠）           |
| **网络层**   | 选择路径、分发数据包，负责不同网段间的传输      | **包（Packet）**   | IP, ICMP, ARP               |
| **数据链路层** | 同一网段中传递帧；用 MAC 地址标识设备；错误检测 | **帧（Frame）**    | Ethernet, PPP, Wi-Fi        |
| **物理层**   | 定义电气特性；传输 0/1 比特流          | **比特（Bit）**     | 光纤、电缆、无线电波                  |

| 层     | 谁跟谁通信   | 地址类型     | 代表数据    |
| ----- | ------- | -------- | ------- |
| 应用层   | 应用 ↔ 应用 | URL / 域名 | HTTP 报文 |
| 传输层   | 进程 ↔ 进程 | 端口号      | TCP 段   |
| 网络层   | 主机 ↔ 主机 | IP 地址    | IP 包    |
| 数据链路层 | 网卡 ↔ 网卡 | MAC 地址   | 帧       |
| 物理层   | 设备 ↔ 设备 | 无        | 比特流     |

说明：物理层和数据链路层为硬件相关，软件开发（前后端）侧重网络层及以上。

**PS：** 作为一个前端或者是后端，我们都是软件开发，所以侧重点放在网络层以上就可以了，物理层和数据链路层都是硬件相关的，所以这两个层下面不会过多叙述，了解即可



## 物理层：

但凡能通信的计算机最终都依赖某种物理连接。

## 数据链路层：

* 利用每个设备在网卡中唯一的出厂地址（MAC），作为以太网协议的一部分

* 以太网协议规定一组电信号构成一个数据包，我们把这个数据包称为 `帧` ，每一个帧由 `标头` 和 `数据` 两部分组成，以太网帧的标头有 18 字节，其中前 6 字节是**发送者的 MAC 地址**（源 MAC 地址），接下来的 6 字节是**接收者的 MAC 地址**（目的 MAC 地址）。

* 广播

  * A如果连接着BCD,就是A会同时给B/C/D发送数据包，这个数据包中会包含着接收者的 `MAC地址` 信息，当B/C/D接收到了数据包，会取出数据包中的 `MAC地址` 与自身的 `MAC地址` 对比，如相同就接收这个数据包，否则就丢弃这个数据包 (  丢包 )，这种方式我们称之为 `广播`。

  * 如果没有更上层的抽象，接收者的 `MAC地址` 信息是自然而然知道的，因为这是我们主动发出的请求，没有目标，请求就发不出去

  * 但是因为数据链路层的局限性，我们还有更高级的抽象，以URL为例，输入易于记忆的域名，经过DNS转换为IP地址，借助IP地址再确定MAC地址，这个过程后续会谈



至此，似乎已经解决了两个设备的通信问题，事实上全球可相互通信的电脑都存在着某种物理连接，但是这种广播的机制应用到全球，那么全世界所有的计算机都能收到这个数据包，然后进行对比再舍弃，那显然不是很好的设计面对这个天然的限制，解决方案是**子网**，以及其背后的整个**网络层（IP协议）**



## 网络层：

1. **逻辑地址（IP地址）：** 我们引入一套新的、逻辑上的、有层级结构的地址系统。IP地址包含了“网络部分”和“主机部分”，就像一个邮件地址包含“城市”和“街道门牌号”。

2. **划分边界（子网）：** 我们人为地将整个大网络切分成无数个小的、可管理的**子网（广播域）**。在子网内部，设备之间可以继续使用高效的数据链路层广播来通信。

3. **设立关卡（路由器）：** 在每个子网的边界上，我们设立一个“网关”或“路由器”。这个设备是唯一连接不同子网的桥梁。

4. **建立规则：**

   * **规则A：** 如果你想找的设备IP地址和你在**同一个子网**，那么就用数据链路层的广播去找它。

   * **规则B：** 如果你想找的设备IP地址和你在**不同的子网**，**不要广播！**&#x76F4;接把数据包交给你的网关（路由器），让它负责帮你转发。



如何判断计算机是否处于同一个子网？比较两个IP地址的网络部分，就是我们人为规定的逻辑地址

有了两台计算机的 `IP地址` 和 `子网掩码` ，我们就可以判断他们是否处在同一子网当中

IP协议定义了IP地址，决定了IP地址的逻辑构成，子网掩码划分了网络和主机部分



假设他们处在同一子网当中，计算机A要和计算机B发送数据时，必须借用物理介质通信

我们还是要走数据链路层和物理层的过程，所以我们需要知道目标计算机的`MAC地址`

我们通过IP地址结合 `ARP协议` 来得到计算机的 `MAC地址`



`ARP协议` 也是通过广播的形式，给同一个子网中每个电脑发送一个数据包，这个数据包会包含接收者的 `IP地址`，对方收到这个数据之后，会取出 `IP地址` 与自身的对比，相同则会把自己的 `MAC地址` 回复给对方，否则就丢弃这个数据包，这样计算机A就知道计算机B的 `MAC地址` 了



如果两台计算机的 IP 不是处于同一个子网之中，这个时候我们就会把数据包发送给网关，然后让网关（路由器），让它负责帮你转发。



## 传输层：



通过 `物理层` / `数据链路层` 以及 `网络层` 的互相协调，我们成功的把数据从计算机A传到了计算机B，可是计算机B里面有各式各样的应用程序，计算机是如何知道这个数据是发给哪个应用程序的呢？



这个时候，`端口` 就上场了，当计算机A传输给计算机B的时候，还得指定一个端口，以供特定的应用程序来接收处理，作为程序员的我们对端口就更熟悉了，端口范围：`0~65535`，其中前1023个端口被系统占用

那么也就是说，传输层的功能就是建立端口到端口的通信，而相比之下网络层的功能是建立主机到主机的通信



有了 `IP` 和 `端口` ，我们才能准确通信，我们输入的IP有些并没有指定端口号，其实是有些传输协议，设定了一些默认端口，例如 `HTTP` 默认是80，`HTTPS` 默认是443，这些端口信息也会包含在数据包里面

传输层最常见了两大协议就是 `TCP协议` 和 `UDP协议`



### 协议细节

1\. 问题修正：TCP/IP协议 vs TCP/UDP协议

关键点：提问“TCP/IP协议与UDP协议的区别”是不严谨的。

原因：TCP/IP是一个协议簇（包含多种协议的集合），而TCP和UDP都是这个协议簇中处于\*\*同一层（传输层）\*\*的两个独立协议。

正确问法：TCP协议和UDP协议的优缺点及区别是什么？

***

2\. TCP协议 vs UDP协议

| 特性   | UDP                 | TCP                   |
| ---- | ------------------- | --------------------- |
| 是否连接 | 无连接 (直接发送数据，无需建立连接) | 面向连接(通信前需“三次握手”建立连接)  |
| 是否可靠 | 不可靠，无流量/拥塞控制        | 可靠，具流量与拥塞控制           |
| 传输关系 | 一对一、一对多、多对多         | 一对一                   |
| 传输方式 | 面向报文                | 面向字节流                 |
| 首部开销 | 小，仅8字节              | 大，至少20字节              |
| 典型应用 | 实时应用（语音、视频、直播）      | 可靠传输（下载、网页、邮件）        |

***

3\. TCP三次握手 (建立连接)

TCP 建立连接之前，双方必须互相确认“我能发”“你能收”。

整个过程可以理解为一次“双向确认”的通信准备。

![](https://rx2wn2pd1qk.feishu.cn/space/api/box/stream/download/asynccode/?code=NWNiN2QwZDMyMjViNDE0ZjE2ODhkNDBkMDMzYmE0NWVfZjZvY2RUaUlEVEJVNGVSb3FIRlAwSzNrVVNxU3BINTNfVG9rZW46UktHd2JkdkJsb3VTQUF4U1F2U2NkZmZjbkpiXzE3NjM5ODg5NTQ6MTc2Mzk5MjU1NF9WNA)

| 步骤    | 发送方（客户端）                             | 接收方（服务器）                                           | 状态变化                                       |
| ----- | ------------------------------------ | -------------------------------------------------- | ------------------------------------------ |
| 第一次握手 | 发送一个带 SYN 标志的数据包（请求连接），并携带初始序号 seq=x | ——                                                 | 客户端进入 `SYN-SENT` 状态                        |
| 第二次握手 | ——                                   | 回复一个 SYN+ACK 包，表示同意连接，并附上自己的初始序号 seq=y，确认号 ack=x+1 | 服务端进入 `SYN-RECEIVED` 状态                    |
| 第三次握手 | 发送一个 ACK 包，确认号 ack=y+1               | ——                                                 | 客户端进入 `ESTABLISHED` 状态，服务端收到后也进入该状态，连接建立成功 |

第一次 (客户端 -> 服务端)：客户端发送SYN包，请求建立连接。

第二次 (服务端 -> 客户端)：服务端收到后，回复SYN+ACK包，表示“我收到了，我也准备好了”。

第三次 (客户端 -> 服务端)：客户端收到后，回复ACK包，表示“我收到你的确认了，现在开始通信吧”。

***

为什么必须三次？

* 为了**防止旧的连接请求报文**（滞留在网络中的 SYN 包）被误认为是新的连接请求。

* 第三次握手的 ACK 让服务端确认：“客户端真的收到了我的确认包，并且这次连接是最新有效的。”



握手时能携带数据吗？

第一次和第二次不能，防止服务器受到攻击。

第三次可以，因为此时客户端已确认服务器的收发能力正常。

***

4\. TCP四次挥手 (断开连接)

这是一个确保双方数据都传输完毕后才关闭的过程。

![](https://rx2wn2pd1qk.feishu.cn/space/api/box/stream/download/asynccode/?code=YmVlOWY3ZGQ1MGY2MDBiY2FjZjg4OGM4ZjFkODA1ZDNfa1d6aXVlVmV1R1lCVXZCV043bDZEbUgydHc3RHBIY0RfVG9rZW46RVg2SWJ5b1dBb1U2UHN4TEF5VGNzZmVBbmZ2XzE3NjM5ODg5NTQ6MTc2Mzk5MjU1NF9WNA)

| 步骤    | 主动关闭方（A）                 | 被动关闭方（B）               | 状态变化                                                    |
| ----- | ------------------------ | ---------------------- | ------------------------------------------------------- |
| 第一次挥手 | A 发送 FIN 报文，表示“我没有数据要发了” | ——                     | A 进入 `FIN-WAIT-1` 状态                                    |
| 第二次挥手 | ——                       | 回复 ACK 表示收到请求          | B 进入 `CLOSE-WAIT`，A 进入 `FIN-WAIT-2`                     |
| 第三次挥手 | ——                       | 当 B 也没有数据要发时，发送 FIN 报文 | B 进入 `LAST-ACK` 状态                                      |
| 第四次挥手 | A 回复 ACK，确认关闭            | ——                     | A 进入 `TIME-WAIT`，等待 2MSL 后进入 `CLOSED`；B 收到后也进入 `CLOSED` |

第一次 (主动方 -> 被动方)：主动方发送FIN包，表示“我的数据发完了，请求关闭”。

第二次 (被动方 -> 主动方)：被动方回复ACK包，表示“收到了你的关闭请求，但我可能还有数据没发完”。

第三次 (被动方 -> 主动方)：被动方发完自己的数据后，发送FIN包，表示“我也没数据了，可以关闭了”。

第四次 (主动方 -> 被动方)：主动方回复ACK包，确认收到，连接关闭。

为什么是四次？

因为TCP是全双工的。



也就是说：

* 双方之间的通信是 **独立的两条通道**。

* 一条负责 A→B 的发送；

* 一条负责 B→A 的发送。

所以，**关闭连接** 其实是：

> 两条独立方向的通道各自关闭。

这就意味着：

* A 说“我发完了”，并不代表 B 也发完了。

* 因此，**必须分别关闭两次发送方向**。

***

5\. 四次挥手后的TIME\_WAIT状态

问题：为什么客户端在第四次挥手后要等待2MSL（最长报文段寿命）？

原因：

* 确保最后一个 ACK 能顺利到达对方。

* 如果对方没收到，会重发 FIN，A 还能再发 ACK。

* 等 2MSL 后说明网络中旧连接的包都过期，安全关闭。

***

6\. TCP的容错机制

问题：如果连接建立后，客户端突然宕机怎么办？

解决方案：TCP设有保活计时器 (Keepalive Timer)。

服务器若在一定时间（如2小时）内没收到客户端任何数据，会主动发送探测报文。

若连续发送多次探测报文均无响应，服务器就会认为客户端故障，自动关闭连接，释放资源。

## 应用层：



应用层是最接触用户的，上面几层我们收到了传输层收到的数据，TCP/UDP协议可以传递各种程序的数据包，就像邮箱/网页/FTP等等，所以就需要不同的协议来规定数据的格式，收到后才能渲染解读，应用层就是由这些协议构成，它的数据包放在UDP包/TCP包的 `数据` 中



我们遨游网络时经常用到的 HTTP 协议、文件传输用的 FTP 协议、电子邮件发送的 SMTP、域名解析的 DNS 协议、远程登录的 Telnet 协议等等都是属于应用层的

还有Socket，它是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作封装成几个简单的接口供应用层调用，从而实现进程在网络中的通信

上面我们已经基本了解到了计算机的一些通信基础，可以说到目前为止从一个IP到通信结束都已经知道了，但是我们输入的是域名不是IP，那么它是怎么变成IP通信的呢？这就要详细说说 `DNS` 了



### DNS解析



```javascript
浏览器缓存
   ↓
系统缓存 / hosts
   ↓
递归解析器（运营商/公共DNS）
   ↓
根服务器
   ↓
顶级域（.com）
   ↓
权威服务器（example.com）
   ↓
返回 IP 地址

```

解析 `www.baidu.com` 的可能路径：

1. 浏览器缓存中没有；

2. 操作系统缓存中没有；

3. 递归解析器询问根服务器；

4. 根服务器告知 `.com` 服务器地址；

5. `.com` 服务器告知 `baidu.com` 的权威服务器；

6. 权威服务器返回 `www.baidu.com` 的 IP；

7. 浏览器使用该 IP 建立 TCP 连接。



用户打开网站的整个流程中，DNS解析是第一环，当用户输入域名并敲回车后，系统调用 `DNS客户端`，寻找到用户配置或者自动分配的`DNS IP`，之后就开始整个解析过程，`DNS服务器` 完成解析到此域名的 `数字IP服务器`，一般情况下返回给定域名对应的IP地址会花费 `20~120毫秒` 的时间，而且在这个过程中浏览器什么都不会做直到DNS查询完毕



如何优化？

#### DNS解析优化-善用缓存之TTL

DNS存在着多级缓存，每次找这么多级，很定耗时间，我们要尽量多的让用户直接从运营商的DNS缓存中拿到解析记录，这样就不需要走根域名服务器以下的这些过程，自然就节省了一些时间， `TTL` 值指的是域名解析的生命周期 ( 秒为单位 )，简单来说它表示DNS服务器解析域名时记录在DNS服务器上的缓存时间，合理设置这个值即可

#### DNS解析优化-负载均衡



> 同一个域名（如 `www.example.com`）可以对应多个不同的服务器 IP。

比如 DNS 记录可以这样写：

`www.example.com   A   192.168.1.1`
`www.example.com   A   192.168.1.2`
`www.example.com   A   192.168.1.3`



> 当不同用户来请求解析时，DNS 服务器**轮流返回**不同的 IP。

例如：

* 第一个用户访问 → 返回 `192.168.1.1`

* 第二个用户访问 → 返回 `192.168.1.2`

* 第三个用户访问 → 返回 `192.168.1.3`

* 第四个再回到 `192.168.1.1`



可以根据每台机器的负载量或该机器离用户地理位置的距离，合理分配IP，这就是**DNS 负载均衡**。

这样不同用户的请求就被分配到不同的服务器上处理，避免一台服务器过载。



#### CDN



CDN（Content Delivery Network，内容分发网络）是互联网中**加速内容访问、分担源站压力**的一项核心技术。
&#x20;它的本质是：

> “让用户从离自己最近的服务器获取内容，而不是每次都访问源站。”



CDN 厂商会让域名的 DNS 指向自己管理的 **智能DNS服务器**。

所以，这时不是普通DNS服务器，而是：

> CDN 的“智能调度系统”来决定返回哪个节点 IP。



CDN 的 DNS 系统会根据以下因素选择最优节点：

* 用户的地理位置（GeoDNS）

* 各节点的实时负载

* 网络运营商（比如移动、电信、联通）

* 节点健康状况（ping、丢包率等）

最终，它返回一个 **距离用户最近、最优的 CDN 节点 IP 地址**。



用户的请求（例如 `GET /index.html`）就会被发往该 CDN 节点。
这个节点就是所谓的 **边缘节点（Edge Server）**。

CDN 节点有一个缓存系统：

* 如果该内容**已经缓存（命中缓存）**，直接返回。

* 如果**没有缓存（缓存未命中）**，则向 **源站（Origin Server）** 请求最新内容。

节点拿到后：

* 把内容缓存起来（根据缓存策略和 TTL）

* 同时返回给用户。



### HTTP & HTTPS



传输层确定了应用程序，那么我们就彻底解决了定位的问题，

除了定位，现在还需要解决沟通的问题，即双方都能理解解析对方的数据，为此http协议规定了数据的格式



#### **HTTP/1.0**

* 每次请求都要重新建立 TCP 连接，请求完就断开；

* 不支持长连接，也没有 Host 字段；

* 浏览器加载多个资源时会非常慢。

👉 所以它的最大问题是 **“连接复用效率太低”**。

***

#### **HTTP/1.1**

* 引入了 **持久连接（Connection: keep-alive）**，一个 TCP 连接可以复用多次请求；

* 增加了 **管线化（Pipelining）** 机制（虽然实际使用不多，因为仍会造成队头阻塞）；

* 支持 **Host 字段**（一个服务器可托管多个网站）；

* 增强了 **缓存控制（Cache-Control、ETag）**；

* 支持 **分块传输（Chunked Encoding）**。

👉 总结一句：
**1.1 解决了连接复用问题，但没解决队头阻塞问题。**

***

#### **HTTP/2.0**

* 改成了 **二进制分帧（Binary Framing）**；

* 实现了 **多路复用（Multiplexing）**，同一条 TCP 连接可以并发多个请求；

* 加入 **头部压缩（HPACK）**，减少重复字段；

* 支持 **服务端推送（Server Push）**；

* 主流实现都基于 **HTTPS（TLS）**。

👉 简单说：
**2.0 彻底解决了队头阻塞问题，性能提升很大。**



#### HTTP 报文结构

🔹 请求报文（Request）

`GET /index.html HTTP/1.1
Host: example.com
User-Agent: Chrome/124
Accept: text/html
（可选的请求体 body）`

由三部分组成：

1. **请求行**（GET /index.html HTTP/1.1）

2. **请求头**（Host、User-Agent、Accept 等）

3. **请求体**（如 POST 表单数据）

***

🔹 响应报文（Response）

`HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1024
 <html> ... </html>`

也分三部分：

1. **状态行**（HTTP/1.1 200 OK）

2. **响应头**（Content-Type、Server 等）

3. **响应体**（HTML、JSON、图片等）



#### 常见方法和状态码

| 方法          | 作用              |
| ----------- | --------------- |
| **GET**     | 获取资源（最常见）       |
| **POST**    | 提交数据（如表单）       |
| **PUT**     | 替换资源            |
| **PATCH**   | 部分更新资源          |
| **DELETE**  | 删除资源            |
| **HEAD**    | 只请求头，不取内容（用于探测） |
| **OPTIONS** | 查询服务器支持哪些方法     |

GET通过URL请求，post通过请求体请求，post能传对象

| 状态码                           | 含义    |
| ----------------------------- | ----- |
| **200 OK**                    | 请求成功  |
| **301 Moved Permanently**     | 永久重定向 |
| **302 Found**                 | 临时重定向 |
| **304 Not Modified**          | 使用缓存  |
| **400 Bad Request**           | 请求错误  |
| **401 Unauthorized**          | 需要认证  |
| **403 Forbidden**             | 无权限访问 |
| **404 Not Found**             | 找不到资源 |
| **500 Internal Server Error** | 服务器错误 |
| **502 Bad Gateway**           | 网关错误  |
| **504 Gateway Timeout**       | 网关超时  |

#### HTTPS



HTTPS = **HTTP + SSL/TLS 加密层**
可以防止中间人攻击、窃听、篡改。



那么简单总结下有区别

* HTTPS协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用

* HTTP是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议

* HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443

* HTTP的连接很简单，是无状态的，HTTPS协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全



### CORS



当浏览器访问资源时，它遵守一个规则叫 **同源策略（Same-Origin Policy）**。

所谓“同源”，指的是：

> **协议（protocol）+ 域名（domain）+ 端口（port）** 三个都相同。



* 你登录了银行网站 `bank.com`；

* 同时你又打开了一个恶意网站 `hacker.com`；

* 如果没有同源策略，`hacker.com` 的 JS 代码就能直接请求并读取你银行账户的接口数据；

* 那就完蛋了。

所以浏览器规定：

> **脚本只能访问同源的资源，防止恶意网站盗取用户信息。**



跨域问题其实是 **浏览器阻止前端访问数据**，所以解决的办法有两种思路：

服务端在响应头中加入：Access-Control-Allow-Origin: \*

或者指定某个域名：

`Access-Control-Allow-Origin: https://your-site.com`

这叫 **CORS（跨域资源共享）机制**。



CORS（Cross-Origin Resource Sharing）是一种标准机制，它定义了浏览器在“跨域”时该如何安全地与服务器通信。



CORS（Cross-Origin Resource Sharing）是一种标准机制，它定义了浏览器在“跨域”时该如何安全地与服务器通信。

根据请求类型不同，CORS 分为：

***

① 简单请求（simple request）

满足以下三个条件：

* 请求方法是 `GET`、`POST`、`HEAD`

* 没有自定义头（只能是常见头，比如 `Accept`、`Content-Type`）

* Content-Type 的值仅限三种：

  * `application/x-www-form-urlencoded`

  * `multipart/form-data`

  * `text/plain`

👉 比如传统的 HTML 表单提交，就是“简单请求”。

&#x20;这种请求浏览器会直接发出，只要服务端响应里带有允许跨域的头即可。

***

② 非简单请求（non-simple request）

只要有一项不满足上面的条件，就算“非简单请求”：

* 使用了 `PUT`、`DELETE` 等方法；

* 使用了自定义头；

* Content-Type 是 `application/json` 等。

这种请求浏览器会**先发一次 “预检请求”**（preflight）。

***

预检请求是浏览器先向服务端“问一句”：

> “我（前端域）能不能用这种方式（PUT/DELETE/JSON）访问你？”

这次请求的 HTTP 方法是：

`OPTIONS`

比如浏览器发的预检：

```javascript
OPTIONS /data HTTP/1.1
Origin: https://front.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Content-Type
```

服务端如果同意，就返回：

```javascript
Access-Control-Allow-Origin: https://front.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Content-Type
```

浏览器看到服务端允许后，才会正式发出真正的 PUT/DELETE 请求。

如果不允许，浏览器直接报错，不会继续。



浏览器看到服务端允许后，才会正式发出真正的 PUT/DELETE 请求。

如果不允许，浏览器直接报错，不会继续。

***

这些方法历史上确实存在，但现在都不推荐使用：

| 方法                     | 原理                       | 问题             |
| ---------------------- | ------------------------ | -------------- |
| **JSONP**              | 利用 `<script src>` 不受同源限制 | 只能发 GET 请求，不安全 |
| **iframe**             | 可以嵌入外域页面                 | 不能读写内容（安全限制）   |
| **降域 document.domain** | 主域相同可设相同 domain          | 现代浏览器几乎弃用      |
| **关闭浏览器跨域检查**          | 开发时临时用                   | 不安全，生产禁止       |

当然，如果可以的话，设置一个「正常」的 Content-Type 头，也有利于减少不必要的跨域的产生，因为只有脚本在跨域之列，如果你给一个 CSS 之类的资源文件不小心设置了一个 JS 的 Content-Type，那也会被跨域拦下来，但是一般前端也不会去干预这个事情。
